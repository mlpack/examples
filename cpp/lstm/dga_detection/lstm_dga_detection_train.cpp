/**
 * @file lstm_dga_detection_train.cpp
 * @author Ryan Curtin
 *
 * This program trains a DGA (domain generation algorithm) detector using two
 * simple LSTM-based RNNs---one trained on benign domains and one trained on
 * malicious domains.  The models are trained and then saved to disk.  The
 * lstm_dga_detection_predict.cpp program can be used for computing predictions,
 * which is done by computing the likelihood of a domain coming from the benign
 * model and from the malicious model.  The predicted class is benign, if the
 * likelihood of the domain coming from the benign model is higher (and
 * malicious if vice versa).
 *
 * To keep the model small and the code fast, we use `float` as a datatype
 * instead of the default `double`.
 *
 * As input, provide a set of DGA domains in a file, in the following format:
 *
 * ```
 * label,domain
 * malicious,baddomain.net
 * benign,mlpack.org
 * ...
 * ```
 *
 * Train the model on the `dga_domains.csv` file in the data/ directory in the
 * repository (once you have run `scripts/download_data_set.py`).
 */

// This must be defined to avoid RNN::serialize() throwing an error---we know
// what we are doing and have manually registered the layer types we care about.
#define MLPACK_ANN_IGNORE_SERIALIZATION_WARNING
#include <mlpack.hpp>

// To keep compilation time and program size down, we only register
// serialization for layers we are planning to use.  Plus, given that we are
// using floats instead of doubles for our data, we need to register the layers
// for serialization either individually or all of them with
// CEREAL_REGISTER_MLPACK_LAYERS() (commented out below).
CEREAL_REGISTER_TYPE(mlpack::Layer<arma::fmat>);
CEREAL_REGISTER_TYPE(mlpack::MultiLayer<arma::fmat>);
CEREAL_REGISTER_TYPE(mlpack::RecurrentLayer<arma::fmat>);
CEREAL_REGISTER_TYPE(mlpack::LSTMType<arma::fmat>);
CEREAL_REGISTER_TYPE(mlpack::LinearType<arma::fmat>);
CEREAL_REGISTER_TYPE(mlpack::LogSoftMaxType<arma::fmat>);

// This will register all mlpack layers with the arma::fmat type.
// It is useful for playing around with the network architecture, but can make
// compilation time a lot longer.  Comment out the individual
// CEREAL_REGISTER_TYPE() calls above if you use the line below.
//
// CEREAL_REGISTER_MLPACK_LAYERS(arma::fmat);

using namespace mlpack;
using namespace std;

// Utility function: map a character to the one-hot encoded dimension that
// represents it.  Characters will be assigned to one of 38 dimensions.  If an
// incorrect character is given, size_t(-1) is returned.
inline size_t CharToDim(const char inC)
{
  char c = tolower(inC);
  if (c >= 'a' && c <= 'z')
    return size_t(c - 'a');
  else if (c >= '0' && c <= '9')
    return 26 + size_t(c - '0');
  else if (c == '-')
    return 36;
  else if (c == '.')
    return 37;
  else
    return size_t(-1);
}

// Utility function: map a set of domains into one-hot encoded data, responses,
// and sequence lengths.  If any domain has an invalid character, the program
// will exit.
void PrepareData(const vector<string>& domains,
                 const size_t maxDomainLen,
                 arma::fcube& data,
                 arma::fcube& responses,
                 arma::urowvec& sequenceLengths)
{
  data.zeros(39 /* last dimension is end of input */, domains.size(), maxDomainLen);
  responses.set_size(1, domains.size(), maxDomainLen);
  sequenceLengths.set_size(domains.size());

  // Build the dataset.
  for (size_t i = 0; i < domains.size(); ++i)
  {
    const string& domain = domains[i];

    // One-hot encode each character.
    for (size_t t = 0; t < domain.size(); ++t)
    {
      const size_t dim = CharToDim(domain[t]);
      if (dim == size_t(-1))
      {
        cerr << "Domain '" << domain << "' has invalid character '" << domain[t]
            << "'!" << endl;
        exit(1);
      }

      data(dim, i, t) = 1.0;

      if (t > 0)
        responses(0, i, t - 1) = dim;
    }

    // Set end-of-input response.
    responses(0, i, domain.size() - 1) = 38;

    sequenceLengths[i] = domain.size();
  }
}

// Utility function: compute the number of correctly predicted points, given
// predictions from the benign and malicious RNNs.
size_t ComputeCorrect(const arma::fcube& benignPredictions,
                      const arma::fcube& maliciousPredictions,
                      const arma::fcube& labels,
                      const arma::urowvec& sequenceLengths,
                      const bool malicious)
{
  size_t correct = 0;
  for (size_t i = 0; i < labels.n_cols; ++i)
  {
    // Compute the likelihood of the sequence being generated by each RNN.
    float benLikelihood = 0.0;
    float malLikelihood = 0.0;
    const size_t steps = sequenceLengths[i];
    for (size_t t = 0; t < steps; ++t)
    {
      const size_t trueDim = labels(0, i, t);
      benLikelihood += benignPredictions(trueDim, i, t);
      malLikelihood += maliciousPredictions(trueDim, i, t);
    }

    const bool predMalicious = (malLikelihood > benLikelihood);
    if (predMalicious == malicious)
      ++correct;
  }

  return correct;
}

int main(int argc, char** argv)
{
  if (argc != 2)
  {
    cerr << "Usage: " << argv[0] << " domains.csv" << endl;
    exit(1);
  }

  // Configuration options are collected here.  Change these if you want to
  // change the behavior of the example.
  const size_t lstmUnits = 50;
  const size_t numEpochs = 5;
  ens::Adam opt(0.002 /* step size */,
                1 /* batch size */,
                0.9, 0.999, 1e-8,
                0 /* number of iterations: this is set later! */,
                1e-10 /* termination tolerance */);

  // The first step is to load the file and parse each domain.
  //
  // We will one-hot encode the letters of each domain, and this will be our
  // input to the network.  This means that our input matrix will be an
  // arma::cube of size:
  //
  //   rows = 39 (26 lowercase letters, 10 digits, period, hyphen, end)
  //   columns = number of domain names
  //   slices = maximum length of domain name
  //
  // For a given domain name (column), each slice will represent a one-hot
  // encoded character in the domain name.  The response at each time step is a
  // non-one-hot-encoded character index of the response.
  //
  // We can't use mlpack's loaders directly here, so we will load manually.
  // The first step is to find the maximum domain name length and the number of
  // domain names in the file.
  fstream f(argv[1]);
  if (!f.is_open())
  {
    cerr << "Could not open dataset '" << argv[1] << "'!" << endl;
    exit(1);
  }

  string line;
  vector<string> benignDomains, maliciousDomains;
  size_t maxBenignDomainLen = 0, maxMaliciousDomainLen = 0, lineNum = 0;
  while (f.good())
  {
    getline(f, line);

    // Skip empty lines.
    if (line.size() == 0)
      continue;

    // Skip header line.
    if (lineNum == 0 && line.substr(0, 5) == "label")
      continue;

    // Find the length of the domain.
    size_t commaPos = line.find(',');
    if (commaPos == string::npos)
    {
      cerr << "Invalid domain on line " << lineNum << ": " << line << endl;
      cerr << "Expected format:" << endl;
      cerr << "  malware,domain.com" << endl;
      cerr << "  benign,domain.org" << endl;
      exit(1);
    }

    const size_t domainLen = line.size() - commaPos - 1;
    if (line.substr(0, commaPos) == "benign")
    {
      benignDomains.push_back(line.substr(commaPos + 1));
      maxBenignDomainLen = std::max(maxBenignDomainLen, domainLen);
    }
    else if (line.substr(0, commaPos) == "malicious")
    {
      maliciousDomains.push_back(line.substr(commaPos + 1));
      maxMaliciousDomainLen = std::max(maxMaliciousDomainLen, domainLen);
    }
    else
    {
      cerr << "Invalid label on line " << lineNum << ": "
          << line.substr(0, commaPos) << endl;
      exit(1);
    }

    ++lineNum;
  }

  cout << "File '" << argv[1] << "' has " << benignDomains.size() << " benign "
      << "domains with a maximum length of " << maxBenignDomainLen << ", and "
      << maliciousDomains.size() << " malicious domains with a maximum length "
      << "of " << maxMaliciousDomainLen << "." << endl;

  // Create the datasets and build them.
  arma::fcube benignDataset, benignResponses, maliciousDataset,
      maliciousResponses;
  arma::urowvec benignLengths, maliciousLengths;

  PrepareData(benignDomains, maxBenignDomainLen, benignDataset, benignResponses,
      benignLengths);
  PrepareData(maliciousDomains, maxMaliciousDomainLen, maliciousDataset,
      maliciousResponses, maliciousLengths);

  // Now split the benign and malicious domains into training and test sets.
  // We also have to consider the sequence lengths, but we can use the
  // three-input version of Split() for this.
  arma::fcube trainBenignInput, testBenignInput, trainBenignResponses,
      testBenignResponses;
  arma::urowvec trainBenignLengths, testBenignLengths;
  data::Split(benignDataset, benignResponses, benignLengths, trainBenignInput,
      testBenignInput, trainBenignResponses, testBenignResponses,
      trainBenignLengths, testBenignLengths, 0.1, true);

  arma::fcube trainMaliciousInput, testMaliciousInput, trainMaliciousResponses,
      testMaliciousResponses;
  arma::urowvec trainMaliciousLengths, testMaliciousLengths;
  data::Split(maliciousDataset, maliciousResponses, maliciousLengths,
      trainMaliciousInput, testMaliciousInput, trainMaliciousResponses,
      testMaliciousResponses, trainMaliciousLengths, testMaliciousLengths, 0.1,
      true);

  // Now we have loaded the dataset.  The next step is to build the network.
  RNN<NegativeLogLikelihoodType<arma::fmat>, RandomInitialization, arma::fmat>
      benignModel(20, false);
  benignModel.Add<LSTMType<arma::fmat>>(lstmUnits);
  benignModel.Add<LinearType<arma::fmat>>(39);
  benignModel.Add<LogSoftMaxType<arma::fmat>>();

  // The malicious model structure is exactly the same as the benign model.
  RNN<NegativeLogLikelihoodType<arma::fmat>, RandomInitialization, arma::fmat>
      maliciousModel = benignModel;

  // Now perform the training of each model.
  opt.MaxIterations() = numEpochs * trainBenignInput.n_cols;
  benignModel.Train(trainBenignInput, trainBenignResponses, trainBenignLengths,
      opt, ens::ProgressBar());
  opt.MaxIterations() = numEpochs * trainMaliciousInput.n_cols;
  maliciousModel.Train(trainMaliciousInput, trainMaliciousResponses,
      trainMaliciousLengths, opt, ens::ProgressBar());

  // Compute performance metrics on the training set and on the test set.
  arma::fcube benignPredictions, maliciousPredictions;
  benignModel.Predict(trainBenignInput, benignPredictions, trainBenignLengths);
  maliciousModel.Predict(trainBenignInput, maliciousPredictions,
      trainBenignLengths);

  const size_t benignTrainCorrect = ComputeCorrect(benignPredictions,
      maliciousPredictions, trainBenignResponses, trainBenignLengths, false);

  benignModel.Predict(trainMaliciousInput, benignPredictions,
      trainMaliciousLengths);
  maliciousModel.Predict(trainMaliciousInput, maliciousPredictions,
      trainMaliciousLengths);

  const size_t maliciousTrainCorrect = ComputeCorrect(benignPredictions,
      maliciousPredictions, trainMaliciousResponses, trainMaliciousLengths,
      true);

  benignModel.Predict(testBenignInput, benignPredictions, testBenignLengths);
  maliciousModel.Predict(testBenignInput, maliciousPredictions,
      testMaliciousLengths);

  const size_t benignTestCorrect = ComputeCorrect(benignPredictions,
      maliciousPredictions, testBenignResponses, testBenignLengths, false);

  benignModel.Predict(testMaliciousInput, benignPredictions, testMaliciousLengths);
  maliciousModel.Predict(testMaliciousInput, maliciousPredictions, testMaliciousLengths);

  const size_t maliciousTestCorrect = ComputeCorrect(benignPredictions,
      maliciousPredictions, testMaliciousResponses, testMaliciousLengths, true);

  // Now compute accuracies for the training and test sets.
  const size_t trainCorrect = benignTrainCorrect + maliciousTrainCorrect;
  const size_t trainSize = trainBenignResponses.n_cols + trainMaliciousResponses.n_cols;
  const double trainAccuracy = 100.0 * ((double) trainCorrect) / trainSize;

  const size_t testCorrect = benignTestCorrect + maliciousTestCorrect;
  const size_t testSize = testBenignResponses.n_cols + testMaliciousResponses.n_cols;
  const double testAccuracy = 100.0 * ((double) testCorrect) / testSize;

  cout << "Model performance:" << endl;
  cout << "  Training accuracy: " << trainCorrect << " of " << trainSize
      << " correct (" << trainAccuracy << "%)." << endl;
  cout << "  Test accuracy:     " << testCorrect << " of " << testSize
      << " correct (" << testAccuracy << "%)." << endl;

  // Save the trained model.
  data::Save("lstm_dga_detector_benign.bin",
             "lstm_model",
             benignModel,
             true /* fatal on failure */);
  data::Save("lstm_dga_detector_malicious.bin",
             "lstm_model",
             maliciousModel,
             true /* fatal on failure */);
}
